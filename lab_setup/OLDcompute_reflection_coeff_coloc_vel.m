% Computing the reflection coefficient from co-located veolocities% following Hughes, 1993 (https://doi.org/10.1016/0378-3839(93)90003-Q)close allclear allclcaddpath(genpath('C:\Users\cmbaker9\Documents\MATLAB\MTOOLS'))addpath(genpath('E:\code\trc_lab_experiment\toolbox'))%% STEP 0: User input% image geometrydx=0.05;  %mixlim=[25 35]; %miylim=[-14 14];  %m% Trial infoTinfo.Hs = 0.30;Tinfo.Tp = 2;Tinfo.tide = 1.07;Tinfo.spread = 0;%% STEP 1: Create paths, files and naming% general path and namesdatapath    = 'E:/';Tinfo = trial_files(Tinfo);% Stereo ReconstructionsTinfo.cam = TRC_camera_info(Tinfo.cam);% Data and figure storage[Tinfo] = wc_comp_store(Tinfo);%% STEP 2: Load PIV output and in situ dataszvsis = 1; % 0=surfzone, 1=inner shelf[~,~,ins] = load_insitu_fullrun(Tinfo,Tinfo.cam.timevec,szvsis);%%insno = 10;m = 256*100/2; % data in each windowfs = 100; % frame rate% [Suu,f,Ci,Di]=fft_coeff_analysis(ins.u(1:end,insno),m,fs);% [Sww,f,Gi,Hi]=fft_coeff_analysis(ins.w(1:end,insno),m,fs);[f,Ci,Di]=calc_fft_coeff(ins.u(:,insno),fs);[f,Gi,Hi]=calc_fft_coeff(ins.w(:,insno),fs);% M = 10000; % [Ci,Di]=coeff(ins.u(:,insno),M);% [Gi,Hi]=coeff(ins.w(:,insno),M);Ei = Gi;Fi = Hi;%% Calculating velocity transfer functionsfcutoff = 2;f(f>fcutoff)=0;g  = 9.81;z =  ins.xyz(3,insno)-Tinfo.tide;h =  -z+0.05;omega   = f*2*pi;cons    = omega.^2*h/g;kh      = dispersi(cons);k       = kh./h;Zi = (g*k./omega).*(cosh(k.*(h+z))./cosh(k*h)); % equation 7Yi = (g*k./omega).*(sinh(k.*(h+z))./cosh(k*h)); % equation 8%% Calc reflection coefficients% % % aIi = 0.5*sqrt((Di+Ei).^2+(Ci-Fi).^2);% phiIi = atan((Di+Ei)./(Ci-Fi));% aRi = 0.5*sqrt((Di-Ei).^2+(Ci+Fi).^2);% phiIi = atan(-(Di-Ei)./(Ci+Fi));aIi = 0.5*sqrt(((Di./Zi)+(Ei./Yi)).^2+((Ci./Zi)-(Fi./Yi)).^2);aRi = 0.5*sqrt(((Di./Zi)-(Ei./Yi)).^2+((Ci./Zi)+(Fi./Yi)).^2);% aIi = 0.5*sqrt(((Di(2:end-1)./Zi)+(Ei(2:end-1)./Yi)).^2+((Ci(2:end-1)./Zi)-(Fi(2:end-1)./Yi)).^2);% aRi = 0.5*sqrt(((Di(2:end-1)./Zi)-(Ei(2:end-1)./Yi)).^2+((Ci(2:end-1)./Zi)+(Fi(2:end-1)./Yi)).^2);figure;loglog(f,aIi,'k')hold onloglog(f,aRi,'r')%%function [A,B]=fcoef(y)% Get length of data vector or number of samplesN=length(y);% Compute Fourier Coefficientsfor p=1:N/2+1    A(p)=0;    B(p)=0;    for n=1:N        A(p)=A(p)+2/N*y(n)*cos(2*pi*(p-1)*n/N)';        B(p)=B(p)+2/N*y(n)*sin(2*pi*(p-1)*n/N)';    end   endA(N/2+1)=A(N/2+1)/2;% Reconstruct Signal - pmax is number of frequencies used in increasing order% pmax=200;% for n=1:N%     ynew(n)=A(1)/2;%     for p=2:pmax%         ynew(n)=ynew(n)+A(p)*cos(2*pi*(p-1)*n/N)+B(p)*sin(2*pi*(p-1)*n/N);%     end% end   % % % Plot Data% plot(y,'o')% % % Plot reconstruction over data% % hold on% plot(ynew,'r')% hold offendfunction [PowSp,f,an,bn]=fft_coeff_analysis(x,m,fs)%%  function [Sp,PowSp,f]=spectrum_analysis(x,y,m,fs);%  NOTE: If calculating power spectrum, the inputs x and y must be same.         %  INPUTS%       x = Data on which the analysis has to be performed( e.g. pressure,velocity)%       m   = Number of points to be used in each fft%       fs  = Sampling frequency(Hz)%       Note: The routine is faster if the length of the time series%       factors into small integers, and fastest if it is a power of 2%   %   OUTPUTS%       PowSp = Power Spectrum/Cross Spectrum from FFT Analysis%       f     = Frequency%       Nirnimesh Kumar%       CPSD Lab, University of South Carolina, Columbia%       March, 2008%       C. M. Baker altered to compute fourier coefficients%       Sept, 2022    points=length(x);       %Number of data points    os=floor(2*points/m);   %Number of overlapping segments    nf=fs/2;                %nf=nyquist frequency    % Check if you have enough number of points to make a segment    if m>points;        error('You have less points than the required segment');    end    %Construction of segments    Is=[1:1:os];    start=((Is-1)*(m/2)+1);    endin=start+m-1;    I=[start(:) endin(:)];    if endin(os)>points        os=os-1;    end    select=[2:m/2];                 %Selecting only positive range of FFT Coefficient    f=(1:(m/2-1))/(m/2)*nf;         %f= frequency bins of un-smoothed estimates    SSE=max(size(select));          %SSE=Number of smoothed spectral estimates    Sp=ones(size([1:m]))*0;    PowSp=ones(size([1:m/2-1]))*0;  %Preparing Power Spectrum/Cross-Spectrum    ao=0;    an=ones(size([1:m]))*0;    bn=ones(size([1:m]))*0;        for IN=1:os;        dd=[I(IN,1):I(IN,2)]';        X=x(dd);        X=detrend(X);                   %Detrending the time series        a1=fft(X);        a3=real((a1.*conj(a1)));        %Equivalent to Cross-spectral analysis(See PhD Thesis,GV)        Sp=Sp+a3';        ao = ao+a1(1);                      % compute fourier coefficients, a0        an = an+-2*real(a1)';           % an        bn = bn+-2*imag(a1)';           % bn    end    %Sp=Sp/(os*nf);                      %Averaging the spectrum     Sp=Sp/os;    ao = ao/os;    an = an/os/m;    bn = bn/os/m;    PowSp=2*Sp/m^2/(f(2)-f(1));         %Normalized two sided power spectrum    PowSp=PowSp(2:m/2);                 %Limit to the same frequencies as power spectra/cross spectra    an = an(2:m/2);    bn = bn(2:m/2);endfunction [f,an,bn]=calc_fft_coeff(x,fs)%%  function [Sp,PowSp,f]=spectrum_analysis(x,y,m,fs);%  NOTE: If calculating power spectrum, the inputs x and y must be same.         %  INPUTS%       x = Data on which the analysis has to be performed( e.g. pressure,velocity)%       m   = Number of points to be used in each fft%       fs  = Sampling frequency(Hz)%       Note: The routine is faster if the length of the time series%       factors into small integers, and fastest if it is a power of 2%%   OUTPUTS%       f     = Frequencym=length(x);       %Number of data pointsnf=fs/2;                %nf=nyquist frequencyf=(1:(m/2-1))/(m/2)*nf;         %f= frequency bins of un-smoothed estimatesX=detrend(x);                   %Detrending the time seriesa1=fft(X)/m;%/(f(2)-f(1));ao = a1(1);                      % compute fourier coefficients, a0an = 2*real(a1)';           % anbn = -2*imag(a1)';           % bnan = an(2:m/2);bn = bn(2:m/2);                 %Limit to the same frequencies as power spectra/cross spectraendfunction [A,B] = coeff(y,M)num_P = length(y);coeff = fft(y(1:num_P),num_P)/num_P; % complex Fourier coefficients% FFT = fft(X,N) => FFT(1)=DC term, FFT(2)=FFT(N), FFT(3)=FFT(N-1), ...% FFT(k)=FFT(N-k+2), ..., FFT(N/2)=FFT(N/2+2) if N is even%                         FFT((N+1)/2)=FFT((N+3)/2) if N is odd% FFT(k) corresponds to increasing frequencies as k increases from 2 to N/2% for even N, or from 2 to (N+1)/2 for odd N.%% FFTsh = fftshift(fft(X,N)) =>% - N even: FFTsh((N+2)/2)=DC term, FFTsh(2)=FFTsh(N), FFTsh(3)=FFTsh(N-1),% ..., FFTsh(k)=FFTsh(N-k+2), ..., FFTsh(N/2)=FFTsh(N/2+2)% - N odd: FFTsh((N+1)/2)=DC term, FFTsh(1)=FFTsh(N), FFTsh(2)=FFTsh(N-1),% ..., FFTsh(k)=FFTsh(N-k+1), ..., FFTsh((N-1)/2)=FFTsh((N+3)/2)% FFTsh(k) corresponds to decreasing frequencies as k increases from 2 to% N/2 for even N or (N-1)/2 for odd N.coeff = coeff(1:M+1);% coeff(2:end) = coeff(2:end).*exp(-2*pi*1i*t0/T*(1:M)).';coeff = [real(coeff(1)) ; 2*real(coeff(2:end)) ; -2*imag(coeff(2:end))];A = coeff(2,:);B = coeff(3,:);end