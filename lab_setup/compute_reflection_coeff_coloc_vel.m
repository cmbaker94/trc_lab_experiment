% Computing the reflection coefficient from co-located veolocities% following Hughes, 1993 (https://doi.org/10.1016/0378-3839(93)90003-Q)close allclear allclcaddpath(genpath('C:\Users\cmbaker9\Documents\MATLAB\MTOOLS'))addpath(genpath('E:\code\trc_lab_experiment\toolbox'))%% STEP 0: User input% image geometrydx=0.05;  %mixlim=[25 35]; %miylim=[-14 14];  %m% Trial infoTinfo.Hs = 0.25;Tinfo.Tp = 2;Tinfo.tide = 1.07;Tinfo.spread = 30;%% STEP 1: Create paths, files and naming% general path and namesdatapath    = 'E:/';Tinfo = trial_files(Tinfo);% Stereo ReconstructionsTinfo.cam = TRC_camera_info(Tinfo.cam);% Data and figure storage[Tinfo] = wc_comp_store(Tinfo);%% STEP 2: Load PIV output and in situ dataszvsis = 0; % 0=surfzone, 1=inner shelf[~,~,ins] = load_insitu_fullrun(Tinfo,Tinfo.cam.timevec,szvsis);%%insno = 8;m = 256*100/2; % data in each windowfs = 100; % frame rate[~,f,Ci,Di]=fft_coeff_analysis(ins.u(:,insno),m,fs);[~,f,Gi,Hi]=fft_coeff_analysis(ins.w(:,insno),m,fs);% [f,Ci,Di]=calc_fft_coeff(ins.u(:,insno),fs);% [f,Gi,Hi]=calc_fft_coeff(ins.w(:,insno),fs);Ei = Gi;Fi = Hi;%% Calculating velocity transfer functionsfcutoff = 2;f(f>fcutoff)=0;g  = 9.81;z =  ins.xyz(3,insno)-Tinfo.tide;h =  -z+0.05;omega   = f*2*pi;cons    = omega.^2*h/g;kh      = dispersi(cons);k       = kh./h;Zi = (g*k./omega).*(cosh(k.*(h+z))./cosh(k*h)); % equation 7Yi = (g*k./omega).*(sinh(k.*(h+z))./cosh(k*h)); % equation 8%% Calc reflection coefficientsaIi = 0.5*sqrt(((Di./Zi)+(Ei./Yi)).^2+((Ci./Zi)-(Fi./Yi)).^2);aRi = 0.5*sqrt(((Di./Zi)-(Ei./Yi)).^2+((Ci./Zi)+(Fi./Yi)).^2);figure;loglog(f,aIi,'k')hold onloglog(f,aRi,'r')loglog(movmean(f,20),movmean(aIi,20),'k','LineWidth',2)hold onloglog(movmean(f,20),movmean(aRi,20),'b','LineWidth',2)%%function [f,an,bn]=calc_fft_coeff(x,fs)%%  function [Sp,PowSp,f]=spectrum_analysis(x,y,m,fs);%  NOTE: If calculating power spectrum, the inputs x and y must be same.         %  INPUTS%       x = Data on which the analysis has to be performed( e.g. pressure,velocity)%       fs  = Sampling frequency(Hz)%%   OUTPUTS%       f     = Frequencym=length(x);       %Number of data pointsnf=fs/2;                %nf=nyquist frequencyf=(1:(m/2-1))/(m/2)*nf;         %f= frequency bins of un-smoothed estimatesX=detrend(x);                   %Detrending the time seriesa1=fft(X)/m;%/(f(2)-f(1));ao = a1(1);                      % compute fourier coefficients, a0an = 2*real(a1)';           % anbn = -2*imag(a1)';           % bnan = an(2:m/2);bn = bn(2:m/2);                 %Limit to the same frequencies as power spectra/cross spectraendfunction [PowSp,f,an,bn]=fft_coeff_analysis(x,m,fs)%%  function [Sp,PowSp,f]=spectrum_analysis(x,y,m,fs);%  NOTE: If calculating power spectrum, the inputs x and y must be same.         %  INPUTS%       x = Data on which the analysis has to be performed( e.g. pressure,velocity)%       m   = Number of points to be used in each fft%       fs  = Sampling frequency(Hz)%       Note: The routine is faster if the length of the time series%       factors into small integers, and fastest if it is a power of 2%   %   OUTPUTS%       PowSp = Power Spectrum/Cross Spectrum from FFT Analysis%       f     = Frequency%       Nirnimesh Kumar%       CPSD Lab, University of South Carolina, Columbia%       March, 2008%       C. M. Baker altered to compute fourier coefficients%       Sept, 2022    points=length(x);       %Number of data points    os=floor(2*points/m);   %Number of overlapping segments    nf=fs/2;                %nf=nyquist frequency    % Check if you have enough number of points to make a segment    if m>points;        error('You have less points than the required segment');    end    %Construction of segments    Is=[1:1:os];    start=((Is-1)*(m/2)+1);    endin=start+m-1;    I=[start(:) endin(:)];    if endin(os)>points        os=os-1;    end    f=(1:(m/2-1))/(m/2)*nf;         %f= frequency bins of un-smoothed estimates        Sp=ones(size([1:m]))*0;    ao=0;    an=ones(size([1:m]))*0;    bn=ones(size([1:m]))*0;        for IN=1:os;        dd=[I(IN,1):I(IN,2)]';        X=x(dd);        X=detrend(X);                   %Detrending the time series        a1=fft(X);        a3=real((a1.*conj(a1)));        %Equivalent to Cross-spectral analysis(See PhD Thesis,GV)        Sp=Sp+a3';        ao = ao+a1(1);                      % compute fourier coefficients, a0        an = an+2*real(a1)';           % an        bn = bn+-2*imag(a1)';           % bn    end    %Sp=Sp/(os*nf);                      %Averaging the spectrum     Sp=Sp/os;    ao = ao/os/m;    an = an/os/m;    bn = bn/os/m;    PowSp=2*Sp/m^2/(f(2)-f(1));         %Normalized two sided power spectrum    PowSp=PowSp(2:m/2);                 %Limit to the same frequencies as power spectra/cross spectra    an = an(2:m/2);    bn = bn(2:m/2);end